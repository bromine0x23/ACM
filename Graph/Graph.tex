\SetPath{graph}

\chapter{图}
\section{结构体定义}
\CPPSource{graph}

\section{最短路(SP, Shortest Path)}
\subsection{SPFA(Shortest Path Faster Algorithm)算法}
\CPPSource{sp_spfa}
\subsection{Dijkstra算法}
\CPPSource{sp_dijkstra}
\subsection{Floyd算法}
\CPPSource{sp_floyd}

\section{最小生成树(MST, Minimum Spanning Tree)}
\subsection{Kruskal算法}
\CPPSource{mst_kruskal}
\subsection{Prim算法}
\CPPSource{mst_prim}

\section{最大流(MF, Maximum Flow)}
\begin{description}
\item[源点／汇点] $s$，$t$
\item[容量] $\forall (u, v)  \in V \times V \;.\; c(u, v) \geqslant 0$, 且$\forall (u, v) \not\in E\;.\; c(u,v) = 0$
\item[流] $f:V \times V \rightarrow \mathbb{R} $，满足：
\begin{description}
\item[容量限制] $\forall (u, v) \in V \times V \;.\; f(u, v) \leqslant c(u, v) $
\item[斜对称] $\forall (u, v) \in V \times V \;.\; f(u, v) = -f(v, u)$
\item[流守恒] $\forall u \in V-\{s, t\} \;.\;\sum_{w \in V} f(u, w) = 0$
\end{description}
\item[剩余容量] $c_f(u,v) = c(u,v) - f(u,v)$
\item[剩余网络] 图$G_f(V, E_f)$，其中$E_f = \{(u,v) \in V \times V : c_f(u, v) > 0\}$
\item[增广路] 路径$(u_1, u_2, \dots, u_k)$，满足$u_1 = s$、$u_k = t$、$c_f(u_i, u_{i+1}) > 0$
\end{description}
\subsection{Ford-Fulkerson算法}
\CPPSource{mf_ford_fulkerson}
\subsection{Edmonds-Karp算法}
\CPPSource{mf_edmonds_karp}
\subsection{Dinic算法(基于层次图)}
\CPPSource{mf_dinic}
\subsection{SAP(Shortest Augmenting Paths，最短增广路)算法}
\CPPSource{mf_sap}

\section{二分图匹配(BGM, Bipartite Graph Matching)}
\subsection{Hungarian算法(匈牙利算法)}
\CPPSource{bgm_hungarian}
\subsection{Hopcroft Karp算法}
\CPPSource{bgm_hopcroft_karp}

\section{强连通分量(SCC, Strongly Connected Component)}
\subsection{Kosaraju算法}
\CPPSource{scc_kosaraju}
\subsection{Tarjan算法}
\CPPSource{scc_tarjan}

\section{最小公共祖先(LCA, Least Common Ancestor)}
\subsection{Tarjan算法}
\CPPSource{lca_tarjan}

\section{最小费用流(MCF, Minimum Cost Flow)}
\subsection{SPFA增广}
\CPPSource{mcf_spfa}
\subsection{Dijkstra增广}
\CPPSource{mcf_dijkstra}